

## 1.JVM，JRE，JDK

​	JVM全称Java Virtual Machine，用来运行Java字节码文件，JVM是Java跨平台关键，因为它屏蔽了不同操作系统之间的差异，可以让相同的Java程序在不同的操作系统上运行出相同的结果。JRE全称Java Runtime Environment，即Java运行时环境，它是运行Java已编译程序所必需的软件环境，包含了JVM、Java标准类库，JRE提供给只想运行Java程序的用户使用，不能用于创建新的程序，即不能将Java源代码编译成字节码文件。JDK，全称Java Development Kit，即Java开发工具包，包含了JRE、编译器以及许多调试、分析等工具软件，它能够创建和编译Java程序。

   简而言之，JDK包含了JRE，JRE包含了JVM，如果只想运行Java程序，只需安装JRE即可（少数情况除外）。如果想要开发Java程序，则需要安装JDK。



## 2.编译型语言与解释型语言，还有JIT

​	高级编程语言按照程序的执行方式分为两种：一种是编译型语言，一种是解释型语言。

​	编译型语言会通过编译器将源代码一次性翻译成机器码，然后执行，一般编译型语言执行速度比较快，常见的编译型语言有C、C++等。解释型语言会通过解释器一句一句地将源代码解释成机器码并执行，一般解释型语言开发效率比较高，常见的解释型语言有Python、JavaScript等。

​	可以发现无论是编译型语言还是解释型语言，都是将源代码译成机器码才能执行，其区别在于：一个是执行前先行编译，一个是在执行期动态解释。

​	为什么一定要翻译成机器码才能执行呢？因为计算机只能直接识别和执行特定的指令集，这些指令集就是机器码，源代码的本质上只是一些文本，只有翻译成机器码才算是一个指令或者说一个程序。为了结合两种类型的优点，发展出了即时编译（JIT），让编译与解释并存，它像编译型语言一样，先把源代码编译成字节码，到执行期间再将字节码直译，然后执行，Java就是这种类型的代表。



##  3.continue、break、return

​	continue 和 break 都作用于循环体，当我们想提前结束循环，就可以用到这两个关键字。两者的区别在于：continue只是结束当前循环，然后执行下一次循环；break是跳出整个循环，继续执行循环体后面的语句。假设正常的循环次数是100次，当执行到50次时，进行了continue，那当前循环会立刻终止，然后执行后50次循环；如果执行到50次时进行了break，则直接结束整个循环体，后50次循环也不执行了。

​	return是作用于方法，用来结束整个方法体。return可以单独被调用，用于没有返回值的方法，也可以携带一个值，用于有返回值的方法。如果将return放在循环体内，它当然也可以直接结束循环，但是要注意，用return结束循环，那循环体后面的语句也不会被执行。



##  4.goto&循环标签

​	continue 和 break 可以改变循环的执行流程，但在多重循环中，这两条语句无法直接从内层循环跳转到外层循环，在一些语言中，比如C，可以通过goto语句实现多重循环的跳转，但在非循环结构中使用goto语句，会使程序的结构紊乱，可读性变差。

​	Java为了防止goto滥用，虽然保留了goto关键字，但这个关键字没有任何作用。然后Java发明了一种带标签的 continue 和 break 语句用来跳出多重循环，实际上它就是一种带限制的，专门用于循环的goto语句，通常情况下我们使用的continue 和 break 语句不带标签，这时就是默认在当前的循环中跳出，带标签的循环实际上就是给这个循环起了名字，当使用 continue 或者 break 加上标签时，那就是在标签所在的循环体执行 continue 或者 break语句。比如我在内层循环中使用break ，那此时内层循环会停止执行，然后执行下一轮外层循环，当我使用break + 外层标签，那此时外层循环便会直接终止。



##  5.逻辑运算符

​	逻辑表达式用来表达结果的真假，它的值是一个逻辑量，为true或者为false，有些语言会用0和非0来表达逻辑值。逻辑运算符就是将逻辑表达式或者逻辑值进行组合和运算，从而得到一个新的逻辑值。

​	逻辑运算符有与运算（&&）、或运算（||）和非运算（！）

​	与运算（&&）和或运算（||）均为双目运算符，即必须携带两个逻辑值进行运算，非运算符（！）为单目运算符，即计算单个值。这里要注意，在Java中我们说的与运算和或运算一般就是指短路与（&&）和短路或（||），在Java中还有非短路与（&）和非短路或（|）。

​	短路和非短路的区别在于，多个表达式结合在一起计算时，若前面的表达式已能得出最终结果，短路运算就不会计算后面的表达式，而非短路运算则无论如何都会执行所有表达式。比如a&&b，当a为false，则b就不参与计算了，如果用非短路与（&），a就算为false，b依然会参与计算。这里也就能明白为什么我们一般使用短路计算，因为它效率更高。   



##  6.重载和重写

​	方法的重载，英文名为Overloading，是指在一个类中定义相同名字，但参数不同的多个方法，调用时会根据不同的参数表达来选择对应的方法，重载方法可以修改返回类型，也可以修改访问权限，但要注意不能只修改这两者，如果只是修改返回类型或访问权限，那调用方根本无法区分实际调用的是哪个方法。

​	简而言之，只要能区分开来方法，不会造成混淆，则构成重载。

​	方法的重写，英文为Overwrite，或Override，是指子类覆盖父类的方法逻辑，子类的重写方法必须和父类的被重写方法具有相同的方法名称、参数列表和返回类型，并且重写方法不能使用比被重写方法更严格的访问权限，比如父类的方法是public，子类的重写方法就不能为private。

​	

|       重载       |         重写         |
| :--------------: | :------------------: |
| 发生在一个类之间 | 发生在子类和父类之间 |
| 必须修改方法参数 |   不能修改方法参数   |



##  7.main方法

​	大部分编程语言必须得声明和指定一个程序入口，这个程序入口往往就是main方法，或者说main函数，比如说C和Java就是如此，在C语言中一个工程内只能声明一个main函数，如若声明多个，则程序无法运行然后报错；Java在一个工程中可以声明多个main方法。当然，尽管可以声明多个main方法，但在程序执行时，必须指定一个main方法作为启动入口。

​	既然Java可以声明多个main方法，那main方法可以被其他方法调用吗？

​	答案是可以的，其实Java中的main方法除了当作程序入口被赋予特殊得意义之外，它本质上还是一个普通的静态方法，既然是普通的方法，那能被其他方法调用也是理所应当的了。



##  8.函数和方法

​	严格来说，函数和方法本质上都是对一段代码的抽象，但两者的含义不同。

​	函数，英文为Function，它是一个独立的功能，与类和对象无关，需要显式地传递数据；方法，英文为Method，它依赖类或者对象，它可以直接处理对象上的数据，也就是隐式地传递数据。

​	在只支持面向过程的语言中，比如C语言，只有函数没有方法，而Java这种面向对象的语言，所有的方法都得依赖类或者对象，所以只有方法没有函数。而在Python中，既有函数也有方法。很多人会将函数叫为方法，方法叫为函数，因其本质相同，称呼混淆了也无伤大雅，但是抱着严谨的态度，还是尽量称呼准确为好。



##  9.final关键字

​	final是Java中一个比较常见的关键字，用在不同的地方会有不同的效果。如果用final来修饰类，则表示这个类不能被继承；如果用final来修饰方法，则表示这个方法不能被子类重写；如果用final修饰变量，则该变量的值在赋值后就无法修改无论是成员变量、静态变量还是局部变量，都是如此。

​	这里要注意，如果修饰的是引用类型，则代表该引用只有一次指向对象的机会，即不能变更变量所指向的对象，但是对象的成员属性是可以修改的。



##  10.三个修饰符、四个访问权限

​	Java中的访问修饰符用来控制类、静态变量、静态方法、成员变量和成员方法的访问权限，为了方便描述，后面简称为变量和方法。

​	在Java中有三个访问修饰符，四种访问权限。先说最容易理解也是用的最多的两种权限，也就是public和private。public是最大权限，代表可以被任意访问；private是最小权限，代表仅可以被自己访问。我们经常将成员变量设置为private，然后选择性地提供public方法，以供外部访问成员变量。

​	再来说一下protected权限，被protected修饰符修饰的成员变量或方法，表示对相同包和其子类可见，protected多用于父类定义好方法模板，供子类去实现自己的逻辑，设计模式中的模板方法就可以通过protected实现。

​	最后说一下默认权限，默认权限没有对应的权限修饰符，当变量或方法没有被权限修饰符修饰时，就属于默认权限。默认权限表示对相同包内可见，默认权限用的比较少，我们在声明变量和方法时一般都会指定具体的修饰符。这里要注意，接口中的方法只能使用public权限，除public外不能加其他的权限修饰符，由于只能加public，所以接口中的方法可以省去权限修饰符，但省去了之后依然是public权限，而不是默认权限。

​	刚才我们说的都是变量和方法，再来说一下类。对于类来说只可以使用public权限和默认权限，也就是只能选择加public和不加public，一个Java文件中只能有一个public类，注意，这里说的是普通类，不包含内部类。内部类可以理解为成员变量或静态变量，既然算是变量，自然可以使用四种访问权限。



##  11.基本类型到对象

​	Java是一门面向对象的语言，它所有的数据都可以看作对象，这种思想是Java的基石和核心。Java一切的特性和设计都是围绕面向对象进行的，但是在Java设计之初有一个例外，那就是基本数据类型。

​	Java中的基本数据类型有byte、short、int、long、float、double、boolean、char，这八种基本类型不是对象，任何和对象相关的特性对它们都无效。

​	这里可以简单证明一下，我们知道所有对象都继承自Object顶层父类，都从Object类中继承过来了几个方法，比如toString()，创建任意一个对象都能调用其toString()方法，然而基本类型却无法调用，这一点就可以得知基本类型确实不是对象。

​	基本类型这个例外让Java的核心概念发生了裂痕，为了弥补，在Java1.5版本推出了新的特性-包装类型，还有装箱和拆箱。Java为每一个基本类型都创造了与之对应的类，从而让基本类型可以转化为对象，这些类称之为包装类，基本类型和包装类互相转换的过程就称之为装箱和拆箱。装箱拆箱无需我们手动进行，Java会自动帮我们做好，将基本类型赋值给包装类型，就完成了自动装箱；将包装类型赋值给基本类型，就完成了自动拆箱。至此，基本类型便可以转换成普通的对象，进而拥有了对象的一切特性，一切皆对象这个概念才算圆满。



##  12.装箱拆箱原理&包装类型缓存池

​	包装类型中有一个特别重要的概念-缓存池。这里缓存池也叫常量池，它是事先储存一些常用数据，用以提高性能、节省空间的一种技术，大部分的包装类型都实现了缓存池。当我们在自动装箱时，如果基本类型的值处在缓存的范围内，则不会重新创建对象，而是复用缓存池中已事先创建好的对象。

​	比如我们将数值8装箱为两个Integer对象，然后一比较就会发现，这两个Integer是同一个对象，即比较结果为true；而当我们将数值128装箱为两个Integer对象，经过比较就会发现这两个Integer不是同一个对象，即比较结果为false，这是因为Integer类型默认缓存了[-128，127]范围的值，只要是这个范围的值自动装箱，便会返回相同的对象，所以如果是包装类型互相比较的话，不要用==判断，而要用equals()方法判断，**注重比较值大小**，不同的包装类缓存的范围不同，参考下表即可。



|  包装类   | 缓存池范围                                      |
| :-------: | ----------------------------------------------- |
|   Byte    | -128~127（所有）                                |
|   Short   | -128~127                                        |
|  Integer  | -128~127（可以通过-xx:AutoBoxCacheMax调整上限） |
|   Long    | -128~127                                        |
| Character | '\u0000'~'\u007F                                |
|  Boolean  | true和false                                     |

​	直接看表格的结果，有点知其然不知所以然，那就再来讲一下包装类到底是怎么缓存的。

​	在此之前我们要先搞懂自动装箱和拆箱的背后原理，当我们查看自动装箱/拆箱的字节码时便会发现，自动装箱实际上是调用了包装类型的valueOf()方法，拆箱实际上是调用了xxxValue()方法。我们点进valueOf()方法，就可以看到缓存池的代码了，缓存的范围、位置、返回的方式在这里都一目了然。

```java
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];
    
    static{
        // 可以通过JVM参数控制上限
        int h = 127;
        
        // ...省去初始化缓存数组等源码
    }
}

public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

​	原理弄清楚后，我们就知道在创建包装类对象时，要么使用自动装箱，要么使用valueOf()方法，而不要直接new。因为valueOf方法利用了缓存，而直接new是直接创建对象，没有利用缓存。



##  13.注释掉的代码也能被执行

​	注释是编程语言中一个重要的组成部分，用来在源代码中解释代码的功能，可以增强程序的可读性、可维护性。注释不会被执行，这是我们刚学编程时就印在脑子里的知识点，然而在Java中，有一种情况打破了我们对注释的认知。

```java
int a = 1;
int b = 1;
// \u000a a = 2;
// \u000d b = 2;
System.out.println(a);
System.out.println(b);
```

​	在以上一段代码中，我们会理所应当的认为a和b打印的结果为1，可事实打印的是2。也就是说，那两行注释掉的代码真的被执行了。上面那段代码其实完全等效于下面这段代码。

```java
int a = 1;
int b = 1;
//
a = 2;
//
b = 2;
System.out.println(a);
System.out.println(b);
```

​	为什么被注释掉的代码会跑到第二行？关键点就出在注释后面的那两个特殊字符上，这两个字符其实是Unicode字符，分别代表着换行和回车，Java源代码允许包含Unicode字符，并且在任何词汇翻译之前，就会对Unicode进行解码，刚才被注释掉的代码就是在Unicode解码后发生了换行和回车，自然而然就被执行了。



##  14.Java版本的选择

​	自2017年起，Java便开始了狂刷版本号，每6个月就会推出一个新版本，摆在Java初学者面前的第一道难关就是该选择哪个版本进行学习。首先，我们得知道关于Java版本的一个重要概念，那就是长期支持版本，缩写为LTS，Java版本从17年起便可以分为两大类，长期支持版本和常规版，常规版只会被官方支持6个月，新版本一出便会放弃老版本的支持服务，而长期支持版会支持多年，在现有版本中Java8、Java11和Java17是长期支持版，下一个长期支持版是Java21，预计在2023年推出。

​	我们都知道选择版本肯定得是长期支持版，那我们现在的筛选范围就从十几个缩小到了三个版本。在Jrebel统计的2021年度Java开发者的语言使用率数据中，Java8占据绝对优势，近七成的使用率；Java11的使用率大约是Java8的一半，其他版本就更低了。

​	这么多年Java8仍然屹立不倒，因为很多时候升级是一件可以，但没有必要的事情，除非迫切需要使用新版本的新特性。所以对很多人来说直接选择目前使用率最高的Java8即可，就目前来说，无论是教程、资料，还是项目、框架，Java8都是主流，使用主流版本进行学习是不会错的。而且Java每个版本都做到了最大程度的向下兼容，无论你选择哪个版本进行学习，所学的知识都不会落伍。等到对Java有一定掌握后，可以根据情况进行多版本选择。



##  15.封装

​	当我们学到面向对象时，基本上都会学面向对象的三大特性—封装、继承、多态，这些概念对于还未养成编程思维的初学者来说，是有点抽象和难以理解的，这里先讲一下封装。

​	封装这一概念不止存在于面向对象中，甚至可以说不仅限于编程中，生活中的封装无处不在。说白了，封装就是隐藏细节。你到银行取钱，只需要提供银行卡和密码就可以得到现金，至于柜员在柜台后面如何验证你的密码、余额，又如何拿到现金给你，你都不知道也无需知道，这就是封装，银行封装了柜员在后面的操作细节。

​	生活中的例子帮助理解概念，我们再来看一下程序中的封装，你调用库中的某个方法来实现某个功能，你只需要传入正确的参数即可让方法运行，达到你想要的结果，至于方法内部进行了怎样的操作，你不知道也无需知道，这就是封装。方法封装了算法的细节，对于对象来说，前面讲到的访问权限就是封装的一种体现。比如我们经常用private修饰成员变量，然后选择性地提供public方法，以供外部访问成员变量，很多新手学到这里可能觉得多此一举，明明可以直接操作成员变量，为什么还要通过get、set方法来操作。

```java
public class User {
    private String phone;
    
    public void setPhone(String phone) {
        if(phone = null || phone.length() != 11){
            System.err.println("手机号必须为11位");
        } else {
            this.phone = phone;
        }
    }
    
    public String getPhone() {
        if (phone != null){
            return phone.substring(0,3) + "****" + phone.substring(7,11);
        }
        return "";
    }
}
```

```java
User user = new User();
user.setPhone("123"); // 打印错误提示
user.setPhone("13700001234"); // 设置成功
System.out. println(user.getPhone()); // 打印137****1234
```

​	举个例子，拿这个对象来说，将phone字段封装起来，外部在调用set方法设置手机号时，便可以限制手机号的长度，然后调用get方法时，可以隐去关键信息，让手机号的中间四位数变成星号*显示，这里就可以体现出封装的好处，它可以对成员进行更精准的控制，让对象和调用者解耦，类内部的结构和实现可以自由修改，同时也能保证数据的安全性、有效性。



##  16.继承

​	这里来讲一下面向对象三大特性中的继承，很多人在学到继承的时候会比较懵，跟着教程一步一步敲了，也知道类有属性和方法，也知道了子类可以将父类的属性和方法继承过来，也写出了猫叫、狗叫、动物叫，但继承关系只要稍微复杂一点，整个人就云里雾里了。实际上将继承关系里最重要的两个概念搞懂了，继承就没什么难的了。这两个概念就是is-a和has-a。

​	is-a，中文称为“是一种”，简单来说，如果你可以这样描述：B是一种A，那么B就继承了A，能通过is-a测试，在逻辑上和程序中就能顺利的使用继承关系，我们还是拿猫叫狗叫动物叫举例。

```java
/*创建两个对象，这肯定没问题*/
Dog dog = new Dog(); // Dog当然是Dog
Cat cat = new Cat(); // Cat当然是Cat

/*这两句也可以通过编译*/
Animal animal1 = new Dog(); // Dog是一种Animal
Animal animal2 = new Cat(); // Cat是一种Animal

/*但是下面两句就无法通过编译*/
Dog dog = new Animal(); // Animal不一定是Dog,所以编译失败
Cat cat = new Animal(); // Animal不一定是Cat,所以编译失败
```

​	现在Dog和Cat 类继承了Animal类，然后来看一下三段代码的编译结果，前两段代码通过了is-a测试，自然是没有问题，而第三段代码没有通过is-a测试，所以编译失败，编译器进行了语法检查，检查的方法是从**=号右边往左读**，右边是不是一种左边呢或者右边类是不是左边类的子类呢，如果答案为是，那么编译就会通过，这三段代码不管是从逻辑上还是程序上都好理解。

```java
Animal animal = new Dog(); // 编译成功
Dog dog = animal; // 编译失败
```

​	我们来看一下这段代码，第二行为什么编译失败呢，因为animal变量是用Animal类来做声明的，自然而然编译器将你认定为Animal类，尽管在第二行指向的是子类Dog，但是现在animal变量的“身份”还是animal类，所以第二行无法通过is-a测试，导致编译失败，编译器会检查父子类之间is-a的关系，如果不想要编译器啰嗦，可以让编译器住嘴。

```java
Animal animal = new Dog();
Dog dog = (Dog)animal;
```

​	这段代码第二行，本来编译器是要提示你animal变量不一定是Dog类的对象，但是你加上强制类型转换，让它住嘴了，编译器就让这段代码通过了编译，不过后果得自行负责。就上面这段代码来说，animal变量确实指向了Dog类对象，所以第二行让Dog类对象转换成Dog没有什么问题，执行期间也不会出错，但是下面这段代码可以通过编译，但是运行时却会报错，你让编译器闭嘴了，编译器让你通过了编译，不过在运行时发现animal变量明明是指向的Dog类，你让Dog转换成Cat，那肯定是不行的，因为Dog并不是一种Cat。

```java
Animal animal = new Dog();
Cat cat = (Cat)animal; // 运行时报错
```

​	综上所述，使用is-a原则，就可以判断何时编译成功，何时编译失败，并留意指向的对象类型，就可以判断何时类型转换成功，何时会抛出异常，然后在要使用继承前，也可以在逻辑上判断是否该使用继承。狗是动物么？是的，所以狗继承动物没有一点问题；猫是动物么？也是，所以猫继承动物也没有问题；苹果是动物么？不是，这在逻辑上也说不过去，所以在程序中也不应该让苹果继承动物类，否则会导致程序的整体逻辑混乱，当然，你可以让Apple extends Animal ，但这样是完全不合理的，作为开发者应当避免这种乱继承的行为。

​	has-a，中文称为“有一个”，它可以用来判断类与成员的关系，比如鸟是一种动物，那它可以继承Animal类，这是is-a，鸟有翅膀，那Bird（鸟）类可以定义一个成员变量为翅膀，这个翅膀的成员变量就不适合定义在Animal类中，也不适合定义在Dog和Cat类中，如果我们想要设计出一个职责清晰的类，那就要好好思考has-a关系。

​	is-a帮助你判断父子类的关系，has-a帮助你判断类与成员的关系。



##  17.多态

​	多态，顾名思义就是多种形态。

​	举个例子方便理解，假设你现在开了个宠物店，给宠物提供洗澡服务，于是你吩咐店员贴一个公告，咱们店可以给所有金毛洗澡，于是附近的居民都带着金毛过来洗澡，这个用程序的语言来描述，就是宠物店提供了一个方法。

```java
// 参数是金毛，执行的功能是洗澡
public void shower(金毛 a);
```

​	但好像有一个问题，有居民带着哈士奇过来，店员不允许哈士奇进店 ，因为你吩咐的是让金毛洗澡，哈士奇不是金毛，所以不行，其他居民带着萨摩耶、柴犬过来，店员都把他们拒之门外了，你失去了很多顾客，但你还没有办法生气，因为店员尽职尽责的执行了你下达的命令，这个店员就是编译器，语法不对的地方，他就让你编译失败。

```java
shower(金毛类的对象); // 通过，因为传进来的参数是匹配的
shower(哈士奇类的对象); // 报错，因为传进来的参数类型不是金毛
shower(萨摩耶类的对象); // 报错，因为传进来的参数类型不是金毛
shower(猫类的对象); // 报错，因为传进来的参数类型不是金毛
```

​	你发现自己做了一件傻事，明明是个宠物店，却只规定让金毛进来洗澡，那生意自然少了很多，于是你决定让各种各样的宠物都可以过来洗澡，因为宠物品种实在是太多了，你必须要考虑各种各样的品种，于是你定义了一万个方法。

```java
// 方法重载

public void shower(金毛 a); // 参数是金毛
public void shower(柴犬 a); // 参数是柴犬
public void shower(萨摩耶 a); // 参数是萨摩耶
...
...
... 
```

​	然而你发现这样成本太高也太麻烦了，问题虽然能够解决，但是却让你精疲力尽，于是你决定改变，你重新吩咐店员。只要是宠物过来就可以享受洗澡服务，这个指令一下达，生意立马就好了，因为别人不管是带着金毛，还是哈士奇、萨摩耶，甚至带猫过来都可以，用程序描述就是现在这段代码，这就是多态的一种体现。你只定义了一个方法和一个类型，但是传进来的参数却各种形态都有，可以很方便。

```java
// 参数是宠物（动物）类，执行的功能是洗澡
public void shower(Animal a);
```

```java
shower(金毛类的对象); // 通过，金毛类继承了Animal类
shower(哈士奇类的对象); // 通过，哈士奇类继承了Animal类
shower(萨摩耶类的对象); // 通过，萨摩耶类继承了Animal类
shower(猫类的对象); // 通过，猫类继承了Animal类
```

​	通过刚才的例子，我们可以总结一下多态的必要条件：

​	1.要有继承。

​	2.父类引用指向子类对象。你参数定义的是Animal类，传进来的参数虽然可以多种多样，但是不能瞎传，得是Animal的子类才可以，然后参数类型是父类，传进来的却是子类，这就是前面is-a原则所体现的父类的引用指向子类的对象。

​	这个理解后，我们再来深入一些。现在你的宠物店决定扩展业务了，不光提供洗澡，还要提供喂食，宠物进食是宠物的行为，在程序中行为就是方法，然后你是照看宠物进食，不是你进食，所以宠物来到宠物店后，你就要让宠物自己进食，即调用宠物的进食方法。

```java
// 宠物类
class Animal {
    // 进食方法
    public void eat() {
        System.out.println("宠物吃东西啦~")；
    }
}

// 你学聪明了，参数一开始设置的就是宠物类，这样所有宠物都可以进来
public void helpEat(Animal a) {
    // 调用宠物本身的进食方法
    a.eat();     // 打印的结果自然是“宠物吃东西啦~”
}
```

​	但是你马上就发现问题了，每个不同的宠物品种喜欢吃的东西都不一样，吃东西的方式也不一样，可是你现在调用的是单一的宠物进食方法，不管是什么宠物进来，打印的都是一句话。所以要解决这个问题，就应该体现出每个宠物品种自身的特性，自身的特性用程序语言描述就是方法的重写。

```java
class 金毛 extends Animal {
    @Override
    public void eat() {
        System.out.println("金毛开始吃狗粮啦~")；
    }
}

class 狸花猫 extends Animal {
    @Override
    public void eat() {
        System.out.println("狸花猫开始吃猫粮啦~")；
    }
}

class 东北虎 extends Animal {
    @Override
    public void eat() {
        System.out.println("东北虎开始吃肉啦~")；
    }
}
```

​	各品种的宠物重写了方法后，宠物店再进行服务的时候，效果就不一样了。

```java
helpEat(金毛对象); // 传进来的参数类型是金毛对象，打印结果是:"金毛开始吃狗粮啦~"
helpEat(狸花猫); // 传进来的参数类型是狸花猫对象，打印结果是:"狸花猫开始吃猫粮啦~"
helpEat(东北虎); // 传进来的参数类型是东北虎对象，打印结果是:"东北虎开始吃肉啦~"
```

​	这里就能看出多态的好处，当父类的引用指向子类的对象时，调用的方法是子类重写后的方法，既体现了多种类型的传递，又体现了不同类型的特性，即复用了父类的属性和方法，又扩展了自己的逻辑，所以继承所用的关键字是extends，而不是inherit，更着重延伸和扩展的意思，注意这里的扩展完全不会影响原有逻辑，你宠物店的方法定义好后，无论宠物的子类怎么扩展，对于当前功能来说，你都无需修改原有代码，这也就是常说的开闭原则，对修改关闭，对扩展开放，可以说多态就是面向对象的核心，它将可扩展性达到了最好。



##  18.本地方法

​	当我们查看Java库的源码时，会将方法一层一层地往下点，但有时候会发现有的方法点不动了，这类方法没有方法体，也没有子类重写，但还能调用，还能正常执行功能，这种方法就是native方法，或者叫本地方法。

​	它们用native关键字来标识，简单来说，本地方法就是Java调用非Java代码的接口，它由非Java语言来实现，比如C语言，当碰到一些用Java不太方便实现的功能时，就可以用到本地方法，你会发现Java库中绝大部分本地方法都是和底层操作系统打交道的功能，它们就调用了C或者C++，甚至是汇编，其实大部分JVM主要也是用C或者C++来实现的。

​	除了Java库以外，我们也可以用native关键字来定义自己的本地方法，然后通过JNI技术调用其他语言的实现，当然，像这种调用其他语言的特性并非Java特有，很多编程语言都有这一机制。



##  19.关于JRE的补充

​	之前介绍了 JVM、JRE、JDK，但是自 JDK11起就只有 JDK 目录，找不到 JRE目录了，这是因为 Java模块化功能出来后我们可以根据自己的需求生成最小化的 JRE，体积小的应用可以达到一二十M，没必要默认再安装一个上百M大小完整的JRE，JDK11尽管没有生成 JRE目录，不代表它就真的没有 JRE了，毕竟没有 JRE是不可以运行 Java程序的。

​	其实JDK包含了JRE内容，对比下两个版本JDK下的bin目录便知 Java11比 Java8多了一个server目录（当然不止多了这个），这下面就放着 jvm 的 dll 文件，这也是为什么在一些需要指定 JRE 的程序中直接指定 JDK 目录便能顺利运行。如果确实需要单独的 JRE 目录也没问题，在 JDK 目录下调用这段命令就可以生成 JRE目录了，这段命令就是Java模块化功能的体现。

```java
bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre
```



##  20.删库

​	删库这个库，一般就是指数据库，拿MySQL关系型数据库来说，执行drop database命令即可删除指定数据库。

​	再说一下常用的非关系型数据库: Redis 和 MongoDB，Redis可以执行 flushall 或者 flushdb 来清除数据，MongoDB可以执行db.dropDatabase()进行删库，但是这些命令清除的数据还不够彻底。

​	比如Redis就可以通过持久化文件恢复数据，为了将数据清理得更彻底一些，就需要用到 **rm-rf**命令了，我们部署好的程序大多运行在Linux系统上，rm就是Unix/Linux的删除文件命令，后面的-r参数是指递归处理，将指定目录下的所有文件及子目录一并删除，-f参数是指强制删除，这两个参数再接上一个根目录就可以删除一切数据。



##  21.接口

​	接口就是一种标准，一种规范。生活中的接口无处不见，比如手机和电脑都有统一的标准接口，让无论是厂商还是用户都方便很多。统一标准和制定规范是各行各业都需要的事情，这种标准和规范就可以理解为接口。

​	延伸到程序，每一项技术的产生肯定是原因的，理解了技术的诞生经过，一般也就理解了技术本身，这里推理一下接口是如何诞生的。

​	假设现在是一个没有对象，只有数据类型和函数的世界，当我们的数据和函数多了，维护起来就会越发困难，于是我们将有关联性质的数据和函数封装了起来，类和对象就这么诞生了，我只需要创建一个对象就拥有了特定的属性和方法，这些属性和方法都聚合在了一个实例上，维护起来比较方便。

​	可还有一个问题，现在大多数类的属性和方法都差不多，完全没必要每次都重新定义，于是我们将这些重复的东西封装到一个类中，其他类只需要复用它即可，继承就这么诞生了。子类继承了父类后，便拥有了父类的属性和方法，同时可以扩展自己的特性，我们经常指定一个父类然后接受多个子类，在程序执行的时候能自行发挥各自子类的特性，这一机制就是我们讲的多态。

​	很多时候我们发现父类完全没必要实现所有逻辑，也没必要创建父类对象，因为我们就是想让各种各样的子类来完成不同的逻辑，这时候我们就可以将父类的方法抽象出来，抽象类就这么诞生了，这里的抽象类其实就已经有标准和规范的意思。抽象方法就可以理解为一个对外的标准，子类就是这些标准的实现方，然后我们会发现抽象类还不算彻底的抽象，因为它除了抽象方法外还有成员属性，可我们很多时候就是想定制一个纯粹的标准，让子类只去实现抽象方法，不想让子类再继承别的东西。

​	于是我们将抽象类更进一步的抽象，接口就这么诞生了，接口只有方法，没有成员属性，子类继承接口后，唯一能做的就是重写方法，所以说接口就是一种标准、一种规范，它规定好方法模板后，都得按这个来实现，这里应该能体会到接口在程序中的作用了—就是定义方法，让子类实现，然后供调用方调用。映射到生活中，子类就是设备厂商，接口调用方就是我们用户，只管使用而不用操心各个设备的差异。

<img src="C:\Users\86189\Desktop\22.jpg" style="zoom: 33%;" />

​	再来讲一讲接口在程序中的具体运用。当我们想操作多个拥有共性的对象时，就可以用到接口。比如，我想打印一个数据集，就可以用到 Java的 Collection 接口，我将方法参数定义成Collection，别人就可以传任何Collection子类进来了，ArrayList可以，HashSet也可以，根本不用关心数据是用哪个集合储存的，Collection有上百个子类，别人爱用哪个就用哪个，都不会影响我的打印逻辑，就好像USB接口定义好后，你想插什么就插什么，U盘也可以，手机充电线也可以，这就是面向接口开发。



##  22.抽象类&接口

​	前面推演了抽象类和接口的诞生过程，这里来讲一下两者的异同，以及什么情况下该用它们。

​	我们已经知道抽象类和接口都是为了将方法进行抽象，然后让子类去实现，所以可以定义抽象方法，就是两者的第一个相同点。然后之前我们也说到，这种父类是没有必要创建实例对象的，所以它们第二个相同点就是不能创建本类对象，只能由子类去实例化子类对象。

​	这里再说说两者最明显的一个差异点，就是子类要扩展它们时，对抽象类用的是extends关键字，我们称之为继承，接口用的是Implements关键字，我们称之为实现，这只是关键字和称呼的不同，本质都一样，然后抽象类可以去实现接口，接口只能继承接口，不能继承类，同时一个类最多只能继承一个父类，但可以实现多个接口，所以当我们发现既可以用抽象类，也可以用接口时，尽量去选择接口，这样子类的灵活度会更高。

​	之前说过抽象类更进一步地抽象后就诞生了接口，接口比抽象类更纯粹，因为它没有了成员属性，只有方法，子类实现接口后唯一能做的就是重写方法，不像抽象类，子类继承抽象类之后连带着将父类的成员属性也继承过来了，这里就是两者的又一差异点，比如抽象类可以定义成员属性，而接口不能定义成员属性，只能定义静态属性，而且只能用final关键字定义静态常量，不能定义静态变量，接口除了没有成员属性外，还没有构造器，可以说是非常纯粹了，说白了，只有方法和静态常量的类。

<img src="C:\Users\86189\Desktop\22.jpg" style="zoom: 33%;" />

​	这里可能会有疑惑，抽象类都不能被实例化，还要构造器有什么用。它的用处就是限定子类的构造行为，比如抽象类可以将构造器定义好几个参数，子类要想实例化则必须想办法传入这几个参数才行。

​	这里还要再讲一下一些重要的版本差异，其实接口在Java8之前更加纯粹，那时接口只能定义抽象方法，不能自己实现方法，也不能定义静态方法，到了 Java8才可以定义静态方法，以及可以用 default关键字来实现方法。这里要注意理解，为什么在 Java8突然加了这个特性呢？因为 Java8许多原有的接口新增了很多方法，这些新增的方法会影响到之前的子类，如果你继承了某个接口，突然接口新增了一个方法，而你没有去实现，你的子类就会编译失败，为了保证向下兼容性，Java8就推出 default关键字，被 default关键字修饰的方法就不是抽象方法了，也就不会强制要求已有的子类去实现方法。default方法出现后，我们发现还挺好用，就大量在接口中去实现一些默认逻辑，可是一个方法中实现复杂逻辑，就会导致代码难以维护，于是 Java9又推出了一个新特性那就是能在接口中定义private方法，这样就可以将一些内部逻辑拆开了，可以发现越到后来抽象类和接口的差异也就越小。

​	那什么时候该用抽象类，什么时候改用接口呢。其实很好判断，当你需要让子类继承成员变量，或者需要控制子类的实例化时，就用抽象类；否则就用接口。

​	总结一下，接口是更加纯粹的抽象类，就能理解两者的异同。接口比抽象类少了成员属性和构造器，只留下了静态常量和方法，更能体现标准和规范的含义，这也是为什么我们经常说要面向接口开发。

> 抽象类和接口的异同

|      | 抽象类（abstrast class)                                      | 接口（interface)                                             |
| ---- | ------------------------------------------------------------ | :----------------------------------------------------------- |
| 定义 | 包含抽象方法的类                                             | 主要是抽象方法和静态常量的类                                 |
| 组成 | 构造器    抽象方法    普通成员方法、成员变量    静态方法、静态变量    常量 | 静态常量    抽象方法    default方法、静态方法（Java8）    私有方法（Java9） |
| 使用 | 子类继承抽象类（extends）                                    | 子类实现接口(implements)                                     |
| 关系 | 子类只能继承一个抽象类；抽象类可以实现多个接口               | 子类可以实现多个接口；接口不能继承类，但可以继承多个接口     |
| 选择 | 如果需要继承父类的成员变量，或者需要控制子类的实例化，选抽象类 | 优先选择接口，避免单继承的局限                               |





##  23.方法冲突

​	上面我们详细讲解了接口，现在讲一下使用接口可能会碰到的问题。

​	我们知道子类最多只能继承一个父类，但可以实现多个接口，然后自 Java8起接口可以定义静态方法，也可以用default关键字实现方法逻辑。这里问题来了，如果一个子类实现了多个接口，这些接口中都有相同签名的方法实现，那子类调用方法时会调用哪一个呢？这就是方法冲突。

```java
public interface A {
    default void run() {
        System.out.println("A Run");
    }
}

public interface B {
    default void run() {
        System.out.println("A Run");
    }
}

public class Son implements A, B {
    public static void main(String[] args) {
        new Son().run()； // 猜猜运行结果？
    }
}
```

​	虽然在日常开发中，发生冲突的概率很小，但我们不能不知道解决方案，如果发生了方法冲突，Java会调用优先级最高的方法。哪些优先级高呢？类的优先级比接口高，子类的优先级比父类高，越具体的越优先，越抽象或者离本类越远的，优先级越低。比如你继承了一个类，同时实现了一个接口，那就会优先调用类的方法，如果你实现了好几个接口，这些接口中有一个是子接口，则会优先调用子接口方法；如果都是相同优先级，无法分出高低时，那本类就必须重写方法来显式地选择方法实现，语法如下面这段代码。

```java
public class Son implements A, B{
    public static void main(String[] args) {
        new Son().run();
    }
    
    @Override
    public void run() {
        A.super.run(); // 打印A Run
    }
}
```

​	父类接上 super 关键字，再接上方法，这里就是固定的语法，不用纠结为什么要这么写，这样就可以解决所有冲突了，默认按照优先级调用，越具体的越优先，如果优先级分不出来，就必须显式地指定方法实现，如果不指定，那就是编译出错。



##  24.Java图形界面技术

​	Java图形用户界面（GUI）这个词可能对许多人来说都特别陌生，Java图形界面技术在商业市场中基本没什么地位。这里图形界面技术是指桌面应用领域，和安卓没什么关系。GUI一共经历了三代技术：AWT—Swing—JavaFX(OpenJFX)，每一代技术都想着解决前一代的弊病，可始终没有掀起风浪，Java官方渐渐对于这方面属于半放弃的状态。所以现在 Java图形界面就处于一个比较尴尬的境地，因为他也有一些成功案例，比如 JetBrains公司用它开发出了优秀的IDE，但是也没什么商业市场。

​	所以到底要不要学习 Java图形界面技术呢。这里的建议是不学，特别是AWT和Swing，这两个技术比较落伍，难用且效果不好，如果碰到这方面的学习跳过就好，对于JavaFX，个人学一学也没什么问题，它的一些特性还是不错的，比如能够支持CSS，这就可以写出比较漂亮的界面，但是还是比较小众，所以教程可能会少一些。

​	每个语言都有各自擅长的方向，Java更擅长服务端应用、分布式系统这些，图形界面技术可以另选其他，比如WPF、WinForm、QT、Electron等。



##  25.static关键字

​	static关键字包括静态属性、静态方法、静态代码块、静态导包，static关键字在 Java中有许多作用，比如在定义属性或者方法时，加上static关键字就代表将其声明为静态属性和静态方法，不用创建对象，直接通过类名便可以调用静态的属性和方法。静态属性和静态方法与之对应的就是成员属性和成员方法，静态的属于类，成员的属于对象。成员方法中，既可以访问成员属性，也可以访问静态属性，静态方法中却只能访问静态属性，不能访问成员属性。

​	听起来有点绕，但是很好理解，每创建一个对象实例，就会随之创建一份成员属性，每个对象的成员属性都各自独立互不影响，而静态的属性和方法是属于这个类的，在当前程序中只存在一份，并且还没有对象创建时它就存在了，所以它又怎么可能访问得了后面创建出来的成员属性呢，其实这里就能解释静态这个词的含义了，因为这个类就这么独一份，它不会像对象一样，可以随时地动态地去创建除了静态的属性和方法，在类中还可以用static关键字来修饰代码块，静态代码块会在类初始化时运行一次；普通的代码块则是每个对象创建时运行一次。

​	这里就要讲一下初始化顺序了，静态属性和静态代码块肯定优先于成员属性和普通代码块，毕竟先有类，然后才有对象，最后才是构造器的初始化。如果有继承关系在，那自然是父类优先于子类。总而言之，类在对象之前，父类在子类之前。



##  26.四种内部类

​	内部类，顾名思义，就是在另一个类的内部定义的类。内部类包括：静态内部类、成员内部类、局部内部类、匿名内部类。不同类型的类，其区别就是作用范围不同，你的类定义在哪，作用范围就是哪，接下来详细阐述这句话。

​	Java中常见的类通常是建立在各个包下面，定义这些常规的类时，可以选择加public关键字，或者不加，加了public就代表这个类可以在本程序任何地方访问；不加则代表只能在这个类所处的包下访问，你这个类能被哪些地方访问，就代表你这个类的作用范围有多大。常规类的作用范围在整个程序或者某个包下，内部类的作用范围就看它定义在哪。静态内部类，一听名字就知道和静态属性相关，它和静态属性一样，被static关键字修饰，作用范围和静态属性一样，你能够怎么样访问这个外部类的静态属性，你就能怎样访问静态内部类；反过来看，这个静态内部类能够任意访问外部类的静态属性，即使private静态属性也没关系，毕竟它们都在同一个作用范围内。

​	照这个思路来看成员内部类，听它的名字就知道和成员属性相关，你怎样定义成员属性就怎样定义成员内部类，对外来说，通过外部类的对象实例就能访问该对象的成员属性，也能访问该对象的成员内部类；对内来说，成员内部类能够任意访问外部类的成员属性，即使是private属性。

​	这里我们发现了规律，你内部类定义在哪，你的作用范围就是哪，我们再来验证一下。

​	局部内部类，一听名字就知道和局部变量有关，局部变量是在方法里面，那局部内部类当然也是定义在方法里面，对外来说，就只有该方法内能调用局部内部类；对内来说，局部内部类可以任意访问该方法内的局部变量，匿名内部类其实就是局部内部类的一种简要写法，可以在不声明类名的情况下继承其它类并创建对象，它的作用范围和局部内部类完全一致。注意，作用范围可以从内往外访问，不能从外往内访问，比如，局部内部类可以访问静态属性或者静态内部类，但静态内部类访问不了局部内部类，就好像你能进卧室，那肯定代表你能进客厅。

<img src="C:\Users\86189\Desktop\33.jpg" style="zoom:80%;" />

​	静态内部类就像静态属性一样，成员内部类的作用范围就像成员属性一样，局部内部类和匿名内部类的作用范围就像局部变量一样。概念很自然，类定义在哪，作用范围就在哪。还是从两个角度来说，对外当你不想让这个类被外部访问时，你就可以使用内部类，根据你自己想限定的作用范围来决定使用哪种，比如你只想让类内部使用，那你就可以定义一个静态内部类，再比如，你只是某个方法需要用到，那你就可以使用匿名内部类；对内，当你想要访问某些内部数据时，就得用到内部类，比如一些类的私有属性，在实际开发中我们用得最多的就是静态内部类和匿名内部类了。Java8起还可以将匿名内部类写成lambda表达式，能够极大简化代码。



##  27.Date

​	我们在日常开发中经常要和日期与时间打交道，Java标准库中java.util包下就提供了一套处理日期和时间的API，主要是Date、Calender和TimeZone这几类，这一套API可以说是Java开发中的烂设计，但还很常用。拿获取年月日来举例：

```java
Date date = new Date();
System.out.println(date.getYear() + 1900);
System.out.println(date.getMonth() + 1);
System.out.println(date.getDate());
```

​	Date对象获取年时必须加上1900才能得到正确结果，获取月时必须加1，因为它用0~11来代表12个月，最后获取当月天数时，它又不用+1了。

​	还有比如Date默认打印格式可读性极差，它和格式化类SimpleDateFormat又都是线程不安全的，时区只能在格式化时体现，Date对象自身并不能处理时区。

```java
Sat Apr 02 12:00:00 CST 2022
```

```java
// 设置格式和时区
SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
format.setTimeZone(TimeZone.getTimeZone("Asia/Nanjing"));

//通过格式化来打印时区信息
Date date = new Date();
System.out.println(format.format(date));
```

​	正是由于这套标准库API太难用，所以催生了许多Date工具类和第三方库，其中比较出名的 Joda-Time，甚至一度成为标配。官方吸收吸收大量 Joda-Time设计，在 Java8版本中终于推出全新的日期时间API，新一代API位于java.time包下，主要包括LocalDateTime、ZoneDateTime等类，完美解决了老一代的问题。所以如果在使用Java8及以上版本，那就弃用Date那些类，用新一代API。



##  28.Java的值传递

​	Java是值传递还是引用传递？这个问题早有定论，Java只有值传递，没有引用传递。在这个知识点我们证明一下这个结论。

​	在此之前我们先搞懂两个概念：实参和形参。实参，就是我们要传递给方法的实际参数；形参，就是我们方法签名上定义的参数。实参在方法外面；形参在方法里面。

```java
public static void main(String[] args) {
    int a = 8; // 实参
    f(a);
}
public static void f(int a) {
    System.out.println(a); // 形参
}
```

​	值传递和引用传递的区别是什么？对形参的修改不会影响到实参，那就是值传递；对形参的修改能够影响到实参就是引用传递。搞清概念后我们来看在Java中的实现。如果我们将基本数据类型传递到方法中，然后在方法内修改形参的值，最后打印实参和形参，可以发现形参修改了并没有影响到实参，这符合值传递。

```java
public static void main(String[] args) {
    int a = 8; 
    f(a);
    System.out.println("实参:" + a);
}
public static void f(int a) {
    a = 16;
    System.out.println("形参:" + a);
}
// 打印结果:
// 形参: 16
// 实参：8
```

​	我们再来看非基本数据类型，也就是对象。

```java
public class Person {
    public String name;
    
    public Person(String name) {
        this.name = name;
    }
    
    @Override
    public String toString() {
        return "Person{" + "name='" + name + '\'' + '}';}
}
```

​	当我们将一个对象变量传递到方法中，然后在方法内修改对象的属性，此时再打印实参和形参。会发现实参和形参的对象都被修改了，这样看起来好像Java也支持引用传递。

```java
public static void main(String[] args) {
    Person p = new Person("张三");
    f(p);
    System.out.println("实参:" + p);
}

public static void f(Person p) {
    p.name = "李四";
    System.out.println("形参:" + p);
}

// 打印结果:
// 形参: Person{name='李四'}
// 实参: Person{name='李四'}
```

​	但是我们再来看这个例子。如果我创建一个新对象，并赋值给形参，此时再打印，会发现实参和形参已经互不影响了。

```java
public static void main(String[] args) {
    Person p = new Person("张三");
    f(p);
    System.out.println("实参:" + p);
}

public static void f(Person p) {
    p = new Person("李四");
    System.out.println("形参:" + p);
}

// 打印结果:
// 形参: Person{name='李四'}
// 实参: Person{name='张三'}
```

​	要理解这些现象，我们要搞懂Java背后的基本原理，JVM中划分了好几块内存区域，其中就有一个栈空间和一个堆空间，我们创建的所有对象都放在堆中，而基本数据类型和局部变量存放在栈中。我们回顾第一个例子，当传递基本数据类型时，是将数据创建了一个副本传递到方法中，那自然形参修改值也不会影响实参，符合值传递。当操作对象时就要注意了，对象是存放在堆中的，我们拿到的只是这个对象的引用，通过对象的引用就可以操作对象，可以将引用理解为遥控器，对象就好像个电视机。这也是为什么我们说Java的数据类型分两种，一种是基本数据类型，一种是引用数据类型。

​	搞懂引用这个概念后我们来回顾一下第二个例子，当对象引用传递给方法时。其实是创建了一个引用副本，此时形参和实参是两个遥控器，但都指向了同一个对象，所以通过形参引用操作对象时，就显得实参好像改变了，但实参本身是没有改变的，因为实参就是个遥控器，电视机内容改变了，遥控器本身并没有改变，所以当我们将形参重新赋值的时候，实参是不会受到任何影响的，此时形参和实参已经指向不同的对象。

​	这里可以看出 **Java完全就是值传递**，如果是基本数据类型，那就是复制一份值传递给形参；如果是引用类型，那就将引用复制一份传递给形参，形参拿到的始终都是一个副本，无论如何都无法通过形参改变实参，毕竟形参只是操作的副本而已。



##  29.==和equals

​	在Java中，==和equals都是用来判断两个数据是否相等，两种方式各有各的应用场景。

​	先来说==，对于基本数据类型来说，它比较的是值；对于引用类型来说，它比较的是对象的内存地址，即判断两个引用是否都指向了同一个对象。之前我们讲过 Java 只有值传递，所以对于==来说，比较的都是值，只不过基本数据类型的值是值本身，引用类型的值是对象地址。

```java
int a = 8;
int b = 8;
System.out.println(a == b); // true

Person p1 = new Person("张三");
Person p2 = p1;
System.out.println(p1 == p2); // true
```

​	==的缺点就是，即使两个对象的属性完全一样，它们也不能算作相等的，如果想要比较两个对象的属性是否相等，就只能用到equals方法了。

```java
Person p1 = new Person("张三");
Person p2 = new Person("张三");
System.out.println(p1 == p2); // false
```

​	equals是Object顶层父类中定义的方法，每个类都能重写该方法，如果没有重写，那equals和==是等价的，一般我们都会将自定义的类重写equals方法来判断两个对象的属性是否一致。我们最常用的引用类型String就重写了equals方法，所以在比较字符串时，我们用equals方法就能得到想要的效果。

```java
public class Object {
    public boolean equals(Object obj) {
        return (this == obj);
    }
}
```

​	用equals方法要注意空指针异常，所以良好的习惯是用常量去比较变量，即将不会为 null 的对象放在前面，可能为 null 的对象放在后面，如果两个对象都可能为 null ，可以用Java标准库中的工具类Objects来进行equals比较，这样就能有效避免空指针异常。

```java
String s1 = null;
String s2 = new String("小猫");

System.out.println("小猫".equals(s1)); // 正常运行
System.out.println(Objects.equals(s1, s2)); // 正常运行
System.out.println(s1.equals(s2)); // 空指针异常
```

​	equals方法还有一个隐蔽的问题就是它不能比较基本数据类型，当比较包装类型时要注意你比较的值是否和包装类型一致，包装类中是重写了equals方法的，它首先会判断另一个值是否为同一类型，比如你包装类型是Long，你很自然地比较了一个数值，而Java中的整型默认为 int 类型，int 类型自动装箱为 Integer 类型后，和 Long 类型不是同一个类，那此时数值虽然相等，但 equals 的结果可不相等。



##  30.hashCode()的用处

​	之前讲了equals()，这里来讲一下和 equals() 常搭配使用的 hashCode()。

​	它和 equals() 一样，都是定义在Object 顶层父类中，子类可以进行重写。hashCode() 是 native 方法，如果没有重写，那它通常会将内存地址转换为 int 数值进行返回。

```java
public class Object {
    public native int hashCode();
}
```

​	我们用 hashCode() 获取到的这个 int 数值，就是哈希码，也叫散列码，它的作用就是确定对象在哈希表中的索引位置，只要搞懂了哈希表的机制，也就能搞懂 hashCode() 了。

​	我们在这里简单推导一下哈希表的基本原理。假设现在有这么一个需求，我想让一批对象能够存储起来，不允许存储重复的对象，并且能够随时获取对象，一说起存储，那自然就想到了数组，我们可以将对象挨个放在数组中，当判断对象是否重复存储时，或者当获取指定对象时，我们每次都得从头遍历数组，挨个和数组中的对象进行 equals() 比较，equals() 结果为真，就代表找到了指定对象，这样确实满足了需求，但是效率太低了，每次都得遍历整个数组，如果数组中有一万个对象，那每次操作我都得比较一万次。

​	怎样提高效率？这时候通过比较 hashCode() 获取到的哈希码就派上用场了，我们在存放对象时，可以通过哈希码来和数组长度取余，这样就能得到数组要存放的位置。比如数组长度为10，对象的哈希码为17，那17除以10会余7，我们就可以将这个对象存放在下标7的位置上，这样无论是存储元素还是获取元素，通过数组下标就只用操作一次。

​	但是有一个问题，哈希码可能会重复，因为哈希码只是通过一定的逻辑计算出来的 int 数值，那两个不同的对象完全可能哈希码相同，这就是哈希冲突。当要存储的对象和已经存储的对象发生哈希冲突时，我们首先要做的就是判断这两个对象是否相等，如果相等，那这就算作重复元素，不用再存储了；如果不相等，我再将对象想别的方法存起来。

​	那怎么判断两个哈希冲突的对象是否相等呢？可以用 equals() ，这里也就能明白为什么 hashCode() 和 equals() 要同时重写，因为 hashCode() 用来定位索引位置，以提高效率的同时，可能会发生哈希冲突，当哈希冲突时，我们就得通过 equals() 来判断冲突的对象是否相等，如果只重写了 hashCode()，那哈希冲突发生时，即使两个对象相等，也不会判定为重复，进而导致数组里会存储一大堆重复对象，如果只重写了 equals() ，那两个相等的对象内存地址可不会相等，这样还是造成重复元素的问题，所以两个方法最好一起重写。

​	最后总结一下， hashCode() 用来在最快的时间内判断两个对象是否相等，并定位索引位置，不过可能会出现误差， equals 方法用来判断两个对象是否绝对相等，hashCode() 用来保证性能，equals() 用来保证可靠。





























