## 1.JVM，JRE，JDK

​	JVM全称Java Virtual Machine，用来运行Java字节码文件，JVM是Java跨平台关键，因为它屏蔽了不同操作系统之间的差异，可以让相同的Java程序在不同的操作系统上运行出相同的结果。JRE全称Java Runtime Environment，即Java运行时环境，它是运行Java已编译程序所必需的软件环境，包含了JVM、Java标准类库，JRE提供给只想运行Java程序的用户使用，不能用于创建新的程序，即不能将Java源代码编译成字节码文件。JDK，全称Java Development Kit，即Java开发工具包，包含了JRE、编译器以及许多调试、分析等工具软件，它能够创建和编译Java程序。

   简而言之，JDK包含了JRE，JRE包含了JVM，如果只想运行Java程序，只需安装JRE即可（少数情况除外）。如果想要开发Java程序，则需要安装JDK。



## 2.编译型语言与解释型语言，还有JIT

​	高级编程语言按照程序的执行方式分为两种：一种是编译型语言，一种是解释型语言。

​	编译型语言会通过编译器将源代码一次性翻译成机器码，然后执行，一般编译型语言执行速度比较快，常见的编译型语言有C、C++等。解释型语言会通过解释器一句一句地将源代码解释成机器码并执行，一般解释型语言开发效率比较高，常见的解释型语言有Python、JavaScript等。

​	可以发现无论是编译型语言还是解释型语言，都是将源代码译成机器码才能执行，其区别在于：一个是执行前先行编译，一个是在执行期动态解释。

​	为什么一定要翻译成机器码才能执行呢？因为计算机只能直接识别和执行特定的指令集，这些指令集就是机器码，源代码的本质上只是一些文本，只有翻译成机器码才算是一个指令或者说一个程序。为了结合两种类型的优点，发展出了即时编译（JIT），让编译与解释并存，它像编译型语言一样，先把源代码编译成字节码，到执行期间再将字节码直译，然后执行，Java就是这种类型的代表。



##  3.continue、break、return

​	continue 和 break 都作用于循环体，当我们想提前结束循环，就可以用到这两个关键字。两者的区别在于：continue只是结束当前循环，然后执行下一次循环；break是跳出整个循环，继续执行循环体后面的语句。假设正常的循环次数是100次，当执行到50次时，进行了continue，那当前循环会立刻终止，然后执行后50次循环；如果执行到50次时进行了break，则直接结束整个循环体，后50次循环也不执行了。

​	return是作用于方法，用来结束整个方法体。return可以单独被调用，用于没有返回值的方法，也可以携带一个值，用于有返回值的方法。如果将return放在循环体内，它当然也可以直接结束循环，但是要注意，用return结束循环，那循环体后面的语句也不会被执行。



##  4.goto&循环标签

​	continue 和 break 可以改变循环的执行流程，但在多重循环中，这两条语句无法直接从内层循环跳转到外层循环，在一些语言中，比如C，可以通过goto语句实现多重循环的跳转，但在非循环结构中使用goto语句，会使程序的结构紊乱，可读性变差。

​	Java为了防止goto滥用，虽然保留了goto关键字，但这个关键字没有任何作用。然后Java发明了一种带标签的 continue 和 break 语句用来跳出多重循环，实际上它就是一种带限制的，专门用于循环的goto语句，通常情况下我们使用的continue 和 break 语句不带标签，这时就是默认在当前的循环中跳出，带标签的循环实际上就是给这个循环起了名字，当使用 continue 或者 break 加上标签时，那就是在标签所在的循环体执行 continue 或者 break语句。比如我在内层循环中使用break ，那此时内层循环会停止执行，然后执行下一轮外层循环，当我使用break + 外层标签，那此时外层循环便会直接终止。



##  5.逻辑运算符

​	逻辑表达式用来表达结果的真假，它的值是一个逻辑量，为true或者为false，有些语言会用0和非0来表达逻辑值。逻辑运算符就是将逻辑表达式或者逻辑值进行组合和运算，从而得到一个新的逻辑值。

​	逻辑运算符有与运算（&&）、或运算（||）和非运算（！）

​	与运算（&&）和或运算（||）均为双目运算符，即必须携带两个逻辑值进行运算，非运算符（！）为单目运算符，即计算单个值。这里要注意，在Java中我们说的与运算和或运算一般就是指短路与（&&）和短路或（||），在Java中还有非短路与（&）和非短路或（|）。

​	短路和非短路的区别在于，多个表达式结合在一起计算时，若前面的表达式已能得出最终结果，短路运算就不会计算后面的表达式，而非短路运算则无论如何都会执行所有表达式。比如a&&b，当a为false，则b就不参与计算了，如果用非短路与（&），a就算为false，b依然会参与计算。这里也就能明白为什么我们一般使用短路计算，因为它效率更高。   



##  6.重载和重写

​	方法的重载，英文名为Overloading，是指在一个类中定义相同名字，但参数不同的多个方法，调用时会根据不同的参数表达来选择对应的方法，重载方法可以修改返回类型，也可以修改访问权限，但要注意不能只修改这两者，如果只是修改返回类型或访问权限，那调用方根本无法区分实际调用的是哪个方法。

​	简而言之，只要能区分开来方法，不会造成混淆，则构成重载。

​	方法的重写，英文为Overwrite，或Override，是指子类覆盖父类的方法逻辑，子类的重写方法必须和父类的被重写方法具有相同的方法名称、参数列表和返回类型，并且重写方法不能使用比被重写方法更严格的访问权限，比如父类的方法是public，子类的重写方法就不能为private。

​	

|       重载       |         重写         |
| :--------------: | :------------------: |
| 发生在一个类之间 | 发生在子类和父类之间 |
| 必须修改方法参数 |   不能修改方法参数   |



##  7.main方法

​	大部分编程语言必须得声明和指定一个程序入口，这个程序入口往往就是main方法，或者说main函数，比如说C和Java就是如此，在C语言中一个工程内只能声明一个main函数，如若声明多个，则程序无法运行然后报错；Java在一个工程中可以声明多个main方法。当然，尽管可以声明多个main方法，但在程序执行时，必须指定一个main方法作为启动入口。

​	既然Java可以声明多个main方法，那main方法可以被其他方法调用吗？

​	答案是可以的，其实Java中的main方法除了当作程序入口被赋予特殊得意义之外，它本质上还是一个普通的静态方法，既然是普通的方法，那能被其他方法调用也是理所应当的了。



##  8.函数和方法

​	严格来说，函数和方法本质上都是对一段代码的抽象，但两者的含义不同。

​	函数，英文为Function，它是一个独立的功能，与类和对象无关，需要显式地传递数据；方法，英文为Method，它依赖类或者对象，它可以直接处理对象上的数据，也就是隐式地传递数据。

​	在只支持面向过程的语言中，比如C语言，只有函数没有方法，而Java这种面向对象的语言，所有的方法都得依赖类或者对象，所以只有方法没有函数。而在Python中，既有函数也有方法。很多人会将函数叫为方法，方法叫为函数，因其本质相同，称呼混淆了也无伤大雅，但是抱着严谨的态度，还是尽量称呼准确为好。



##  9.final关键字

​	final是Java中一个比较常见的关键字，用在不同的地方会有不同的效果。如果用final来修饰类，则表示这个类不能被继承；如果用final来修饰方法，则表示这个方法不能被子类重写；如果用final修饰变量，则该变量的值在赋值后就无法修改无论是成员变量、静态变量还是局部变量，都是如此。

​	这里要注意，如果修饰的是引用类型，则代表该引用只有一次指向对象的机会，即不能变更变量所指向的对象，但是对象的成员属性是可以修改的。



##  10.三个修饰符、四个访问权限

​	Java中的访问修饰符用来控制类、静态变量、静态方法、成员变量和成员方法的访问权限，为了方便描述，后面简称为变量和方法。

​	在Java中有三个访问修饰符，四种访问权限。先说最容易理解也是用的最多的两种权限，也就是public和private。public是最大权限，代表可以被任意访问；private是最小权限，代表仅可以被自己访问。我们经常将成员变量设置为private，然后选择性地提供public方法，以供外部访问成员变量。

​	再来说一下protected权限，被protected修饰符修饰的成员变量或方法，表示对相同包和其子类可见，protected多用于父类定义好方法模板，供子类去实现自己的逻辑，设计模式中的模板方法就可以通过protected实现。

​	最后说一下默认权限，默认权限没有对应的权限修饰符，当变量或方法没有被权限修饰符修饰时，就属于默认权限。默认权限表示对相同包内可见，默认权限用的比较少，我们在声明变量和方法时一般都会指定具体的修饰符。这里要注意，接口中的方法只能使用public权限，除public外不能加其他的权限修饰符，由于只能加public，所以接口中的方法可以省去权限修饰符，但省去了之后依然是public权限，而不是默认权限。

​	刚才我们说的都是变量和方法，再来说一下类。对于类来说只可以使用public权限和默认权限，也就是只能选择加public和不加public，一个Java文件中只能有一个public类，注意，这里说的是普通类，不包含内部类。内部类可以理解为成员变量或静态变量，既然算是变量，自然可以使用四种访问权限。



##  11.基本类型到对象

​	Java是一门面向对象的语言，它所有的数据都可以看作对象，这种思想是Java的基石和核心。Java一切的特性和设计都是围绕面向对象进行的，但是在Java设计之初有一个例外，那就是基本数据类型。

​	Java中的基本数据类型有byte、short、int、long、float、double、boolean、char，这八种基本类型不是对象，任何和对象相关的特性对它们都无效。

​	这里可以简单证明一下，我们知道所有对象都继承自Object顶层父类，都从Object类中继承过来了几个方法，比如toString()，创建任意一个对象都能调用其toString()方法，然而基本类型却无法调用，这一点就可以得知基本类型确实不是对象。

​	基本类型这个例外让Java的核心概念发生了裂痕，为了弥补，在Java1.5版本推出了新的特性-包装类型，还有装箱和拆箱。Java为每一个基本类型都创造了与之对应的类，从而让基本类型可以转化为对象，这些类称之为包装类，基本类型和包装类互相转换的过程就称之为装箱和拆箱。装箱拆箱无需我们手动进行，Java会自动帮我们做好，将基本类型赋值给包装类型，就完成了自动装箱；将包装类型赋值给基本类型，就完成了自动拆箱。至此，基本类型便可以转换成普通的对象，进而拥有了对象的一切特性，一切皆对象这个概念才算圆满。



##  12.装箱拆箱原理&包装类型缓存池

​	包装类型中有一个特别重要的概念-缓存池。这里缓存池也叫常量池，它是事先储存一些常用数据，用以提高性能、节省空间的一种技术，大部分的包装类型都实现了缓存池。当我们在自动装箱时，如果基本类型的值处在缓存的范围内，则不会重新创建对象，而是复用缓存池中已事先创建好的对象。

​	比如我们将数值8装箱为两个Integer对象，然后一比较就会发现，这两个Integer是同一个对象，即比较结果为true；而当我们将数值128装箱为两个Integer对象，经过比较就会发现这两个Integer不是同一个对象，即比较结果为false，这是因为Integer类型默认缓存了[-128，127]范围的值，只要是这个范围的值自动装箱，便会返回相同的对象，所以如果是包装类型互相比较的话，不要用==判断，而要用equals()方法判断，不同的包装类缓存的范围不同，参考下表即可。



|  包装类   | 缓存池范围                                      |
| :-------: | ----------------------------------------------- |
|   Byte    | -128~127（所有）                                |
|   Short   | -128~127                                        |
|  Integer  | -128~127（可以通过-xx:AutoBoxCacheMax调整上限） |
|   Long    | -128~127                                        |
| Character | '\u0000'~'\u007F                                |
|  Boolean  | true和false                                     |

​	直接看表格的结果，有点知其然不知所以然，那就再来讲一下包装类到底是怎么缓存的。

​	在此之前我们要先搞懂自动装箱和拆箱的背后原理，当我们查看自动装箱/拆箱的字节码时便会发现，自动装箱实际上是调用了包装类型的valueOf()方法，拆箱实际上是调用了xxxValue()方法。我们点进valueOf()方法，就可以看到缓存池的代码了，缓存的范围、位置、返回的方式在这里都一目了然。

```java
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];
    
    static{
        // 可以通过JVM参数控制上限
        int h = 127;
        
        // ...省去初始化缓存数组等源码
    }
}

public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

​	原理弄清楚后，我们就知道在创建包装类对象时，要么使用自动装箱，要么使用valueOf()方法，而不要直接new。因为valueOf方法利用了缓存，而直接new是直接创建对象，没有利用缓存。



##  13.注释掉的代码也能被执行

​	注释是编程语言中一个重要的组成部分，用来在源代码中解释代码的功能，可以增强程序的可读性、可维护性。注释不会被执行，这是我们刚学编程时就印在脑子里的知识点，然而在Java中，有一种情况打破了我们对注释的认知。

```java
int a = 1;
int b = 1;
// \u000a a = 2;
// \u000d b = 2;
System.out.println(a);
System.out.println(b);
```

​	在以上一段代码中，我们会理所应当的认为a和b打印的结果为1，可事实打印的是2。也就是说，那两行注释掉的代码真的被执行了。上面那段代码其实完全等效于下面这段代码。

```java
int a = 1;
int b = 1;
//
a = 2;
//
b = 2;
System.out.println(a);
System.out.println(b);
```

​	为什么被注释掉的代码会跑到第二行？关键点就出在注释后面的那两个特殊字符上，这两个字符其实是Unicode字符，分别代表着换行和回车，Java源代码允许包含Unicode字符，并且在任何词汇翻译之前，就会对Unicode进行解码，刚才被注释掉的代码就是在Unicode解码后发生了换行和回车，自然而然就被执行了。



##  14.Java版本的选择

​	自2017年起，Java便开始了狂刷版本号，每6个月就会推出一个新版本，摆在Java初学者面前的第一道难关就是该选择哪个版本进行学习。首先，我们得知道关于Java版本的一个重要概念，那就是长期支持版本，缩写为LTS，Java版本从17年起便可以分为两大类，长期支持版本和常规版，常规版只会被官方支持6个月，新版本一出便会放弃老版本的支持服务，而长期支持版会支持多年，在现有版本中Java8、Java11和Java17是长期支持版，下一个长期支持版是Java21，预计在2023年推出。

​	大家都知道选择版本肯定得是长期支持版，那我们现在的筛选范围就从十几个缩小到了三个版本。在Jrebel统计的2021年度Java开发者的语言使用率数据中，Java8占据绝对优势，近七成的使用率；Java11的使用率大约是Java8的一半，其他版本就更低了。

​	这么多年Java8仍然屹立不倒，因为很多时候升级是一件可以，但没有必要的事情，除非迫切需要使用新版本的新特性。所以对很多人来说直接选择目前使用率最高的Java8即可，就目前来说，无论是教程、资料，还是项目、框架，Java8都是主流，使用主流版本进行学习是不会错的。而且Java每个版本都做到了最大程度的向下兼容，无论你选择哪个版本进行学习，你所学的知识都不会落伍。等到对Java有一定掌握后，可以根据情况进行多版本选择。



##  15.封装

​	当我们学到面向对象时，基本上都会学面向对象的三大特性—封装、继承、多态，这些概念对于还未养成编程思维的初学者来说，是有点抽象和难以理解的，这里先讲一下封装。

​	封装这一概念不止存在于面向对象中，甚至可以说不仅限于编程中，生活中的封装无处不在。说白了，封装就是隐藏细节。你到银行取钱，只需要提供银行卡和密码就可以得到现金，至于柜员在柜台后面如何验证你的密码、余额，又如何拿到现金给你，你都不知道也无需知道，这就是封装，银行封装了柜员在后面的操作细节。

​	生活中的例子帮助理解概念，我们再来看一下程序中的封装，你调用库中的某个方法来实现某个功能，你只需要传入正确的参数即可让方法运行，达到你想要的结果，至于方法内部进行了怎样的操作，你不知道也无需知道，这就是封装。方法封装了算法的细节，对于对象来说，前面讲到的访问权限就是封装的一种体现。比如我们经常用private修饰成员变量，然后选择性地提供public方法，以供外部访问成员变量，很多新手学到这里可能觉得多此一举，明明可以直接操作成员变量，为什么还要通过get、set方法来操作。

```java
public class User {
    private String phone;
    
    public void setPhone(String phone) {
        if(phone = null || phone.length() != 11){
            System.err.println("手机号必须为11位");
        } else {
            this.phone = phone;
        }
    }
    
    public String getPhone() {
        if (phone != null){
            return phone.substring(0,3) + "****" + phone.substring(7,11);
        }
        return "";
    }
}
```

```java
User user = new User();
user.setPhone("123"); // 打印错误提示
user.setPhone("13700001234"); // 设置成功
System.out. println(user.getPhone()); // 打印137****1234
```

​	举个例子，拿这个对象来说，将phone字段封装起来，外部在调用set方法设置手机号时，便可以限制手机号的长度，然后调用get方法时，可以隐去关键信息，让手机号的中间四位数变成星号*显示，这里就可以体现出封装的好处，它可以对成员进行更精准的控制，让对象和调用者解耦，类内部的结构和实现可以自由修改，同时也能保证数据的安全性、有效性。



##  16.继承

​	这里来讲一下面向对象三大特性中的继承，很多人在学到继承的时候会比较懵，跟着教程一步一步敲了，也知道类有属性和方法，也知道了子类可以将父类的属性和方法继承过来，也写出了猫叫、狗叫、动物叫，但继承关系只要稍微复杂一点，整个人就云里雾里了。实际上将继承关系里最重要的两个概念搞懂了，继承就没什么难的了。这两个概念就是is-a和has-a。

​	is-a，中文称为“是一种”，简单来说，如果你可以这样描述：B是一种A，那么B就继承了A，能通过is-a测试，在逻辑上和程序中就能顺利的使用继承关系，我们还是拿猫叫狗叫动物叫举例。

```java
/*创建两个对象，这肯定没问题*/
Dog dog = new Dog(); // Dog当然是Dog
Cat cat = new Cat(); // Cat当然是Cat

/*这两句也可以通过编译*/
Animal animal1 = new Dog(); // Dog是一种Animal
Animal animal2 = new Cat(); // Cat是一种Animal

/*但是下面两句就无法通过编译*/
Dog dog = new Animal(); // Animal不一定是Dog,所以编译失败
Cat cat = new Animal(); // Animal不一定是Cat,所以编译失败
```

​	现在Dog和Cat 类继承了Animal类，然后来看一下三段代码的编译结果，前两段代码通过了is-a测试，自然是没有问题，而第三段代码没有通过is-a测试，所以编译失败，编译器进行了语法检查，检查的方法是从=号右边往左读，右边是不是一种左边呢或者右边类是不是左边类的子类呢，如果答案为是，那么编译就会通过，这三段代码不管是从逻辑上还是程序上都好理解。

```java
Animal animal = new Dog(); // 编译成功
Dog dog = animal; // 编译失败
```

​	我们来看一下这段代码，第二行为什么编译失败呢，因为animal变量是用Animal类来做声明的，自然而然编译器将你认定为Animal类，尽管在第二行指向的是子类Dog，但是现在animal变量的“身份”还是animal类，所以第二行无法通过is-a测试，导致编译失败，编译器会检查父子类之间is-a的关系，如果不想要编译器啰嗦，可以让编译器住嘴。

```java
Animal animal = new Dog();
Dog dog = (Dog)animal;
```

​	这段代码第二行，本来编译器是要提示你animal变量不一定是Dog类的对象，但是你加上强制类型转换，让它住嘴了，编译器就让这段代码通过了编译，不过后果得自行负责。就上面这段代码来说，animal变量确实指向了Dog类对象，所以第二行让Dog类对象转换成Dog没有什么问题，执行期间也不会出错，但是下面这段代码可以通过编译，但是运行时却会报错，你让编译器闭嘴了，编译器让你通过了编译，不过在运行时发现animal变量明明是指向的Dog类，你让Dog转换成Cat，那肯定是不行的，因为Dog并不是一种Cat。

```java
Animal animal = new Dog();
Cat cat = (Cat)animal; // 运行时报错
```

​	综上所述，使用is-a原则，就可以判断何时编译成功，何时编译失败，并留意指向的对象类型，就可以判断何时类型转换成功，何时会抛出异常，然后在要使用继承前，也可以在逻辑上判断是否该使用继承。狗是动物么？是的，所以狗继承动物没有一点问题；猫是动物么？也是，所以猫继承动物也没有问题；苹果是动物么？不是，这在逻辑上也说不过去，所以在程序中也不应该让苹果继承动物类，否则会导致程序的整体逻辑混乱，当然，你可以让Apple extends Animal ，但这样是完全不合理的，作为开发者应当避免这种乱继承的行为。

​	has-a，中文称为“有一个”，它可以用来判断类与成员的关系，比如鸟是一种动物，那它可以继承Animal类，这是is-a，鸟有翅膀，那Bird（鸟）类可以定义一个成员变量为翅膀，这个翅膀的成员变量就不适合定义在Animal类中，也不适合定义在Dog和Cat类中，如果我们想要设计出一个职责清晰的类，那就要好好思考has-a关系。

​	is-a帮助你判断父子类的关系，has-a帮助你判断类与成员的关系。



















