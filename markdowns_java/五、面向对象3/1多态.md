- 多态（封装和继承都是为了实现多态）

- 意味着允许不同类的对象对同一消息做出不同相应

- 必要条件

  - 满足继承关系
  - 父类引用指向子类对象

- 向上转型：父类引用指向子类实例（隐式转型，小范围自动转型为大范围）可以使用从父类继承来的属性和方法，也可以使用由子类重写的属性和方法，但是无法执行子类自己独有的成员（**向上变高了，暂时升级为假的父类**）

- 向下转型：子类引用指向父类对象（强制转换，大范围需要强制转换为小范围，类似于基本数据类型的强制转换），必须满足必要条件才能进行转型（**向下变回原样了，还原为子类**）

- 对象 instanceof 类：返回一个布尔值，判断该对象是否是这个类的一个实例

- 我们在Master类里面定义一个feed方法，feed重载为单参数Cat类和单参数Dog类，在feed里面实现对应的逻辑，那如果又喂养了其他动物乌龟，鹦鹉等等，**这意味着我们需要改动Master类！**，这就会导致两个问题：

  1. 频繁改动父类
  2. 我们也不知道有多少子类，不知道要重载多少次feed方法

  解决方法是利用多态，我们把单参数改为Animal类，只要其他新的动物继承至Animal，我们就可以在feed里面调用Animal共有的方法

- 多态的两个例子

  - 在方法里面接收父类的参数
  - 返回值使用父类承接子类

- 父类的static方法不能被重写，子类同名的static方法并没有重写（可以用Override验证），向上转型的无法访问到子类重写的静态方法，向上转型只能做到访问公共的成员，只有进行**向下转型**之后才能访问到子类的独有的成员<font  color="red">red</font>





- 抽象类
- new Animal();Animal是一个抽象的概念，并不是具体哪一种动物，Animal存在的意义就是为了被子类继承，实现动物多样性（多态），因此，实例化一个Animal是没有意义的，我们为了避免这样的现象，可以把Animal类定义成一个抽象类，**抽象类不可以被实例化**，可以用向上转型指向子类实例
- 应用场景：某个父类只是知道子类应该包含怎么样的方法，但是无法知道子类怎么样实现这些方法
  - 父类：无意义的实例化
  - 子类：设计的随意性
- 用abstract修饰类，该类不能被实例化，用abstract修饰方法，这个方法不能有具体的实现，子类继承这个父类之后，必须实现父类的abstract方法，抽象方法只能存在于抽象类里面，抽象类里面可以没有抽象方法
- 定义成抽象类的好处，其中之一，强制提醒子类必须要重写父类的抽象方法，不然在编译时期就会报错
- abstract（需要被继承）与static（不能被重写）, private（只能在本类使用）, final（不能被继承）矛盾，因此**不能共存**
- 子类如果没有重写父类所有的抽象方法，那么子类也要被定义为抽象类