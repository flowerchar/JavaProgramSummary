- 继承

- 优点

  - 利于代码复用
  - 缩短开发周期

- 使用已经存在的类（父类|基类）作为基础建立新类（子类|派生类）

- 访问权限修饰符

  - private:只允许在本类中进行访问 public:允许在任意位置访问

  - protected:允许在当前类、同包子类/非子类、跨包子类调用；跨包非子类不允许
  
  - 默认：允许在当前类、同包子类/非子类调用；跨包子类/非子类不允许调用
  
  - 一个java文件必须只能有一个public类
  
  - | 访问范围         | private  | default  | protected | public |
    | ---------------- | -------- | -------- | --------- | ------ |
    | 同一个类         | 可访问   | 可访问   | 可访问    | 可访问 |
    | 同一包中的其他类 | 不可访问 | 可访问   | 可访问    | 可访问 |
    | 不同包中的子类   | 不可访问 | 不可访问 | 可访问    | 可访问 |
    | 不同包中的非子类 | 不可访问 | 不可访问 | 不可访问  | 可访问 |
  
- 子类可以访问父类公共属性

- 父类不能访问子类特殊属性

- 继承逻辑

  1. 初始化父类的静态成员（属性，代码块）
  2. 初始化子类的静态成员（属性，代码块）
  3. 初始化父类的构造代码块
  4. 初始化父类的构造器
  5. 初始化子类的构造代码块
  6. 初始子类的构造器

- 方法重载：

  - 在同一个类中
  - 方法名相同，参数列表不同（参数顺序，个数，类型）
  - 方法返回值，访问修饰符任意
  - 与方法的参数名无关

- 方法重写

  - 在子类中定义

  - 方法名一致

  - 参数类型，顺序，个数一致

  - 当方法返回值是void或基本数据类型时，必须相同；当返回值是引用类型时，可以是父类或其子类

  - 子类重写的方法权限符必须不能低于父类

  - 父类的构造方法不允许被继承，不允许被重写

    > 在子类的构造器里会隐式调用父类无参构造器(*除非**显式**指明其他构造器*，且必须放在**第一行**)，为什么？因为子类继承过来父类的属性和方法后，首先应该对这些资源进行初始化后，才能够使用。那么在继承里的初始化顺序就是：**父类静态成员**(*静态成员无论属性还是方法，按在类中的先后顺序执行*)\==>**子类静态成员**\==>**父类对象构造**==>**子类对象构造**

- 静态属性也可以被重写

- super：父类对象的引用

