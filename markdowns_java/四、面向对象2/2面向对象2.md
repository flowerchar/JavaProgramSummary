- Object是所有类的父类（数组也继承至Object）
- Object常用的方法：
  - equals：比较两个对象的引用是否一致（在空间里俩对象的地址是否相等）。==比较的是值是否一致，equals方法比较的具体实现由开发者自己定义，在String类中就重写了equals方法，比较的不再是引用，而是其内部的数据是否相等。开发者应该按照自定义的逻辑，定制自己类的equals方法。
  - toString：实现逻辑 this.getClass().getName() + "@" + Integer.toHexString(this.hashCode())。打印当前对象时会默认调用类中的toString方法，String重写了toString方法，会直接打印出这个对象的内容、
  - ==对于基本数据类型比较是值，对于对象比较的是地址
- final：最终的，不可更改的，保持原状的
  - 修饰变量，指向该对象的变量不能指向其他
    - 只是先声明一个final的变量，可以在之后赋值一次
    - 只是先声明一个final的成员变量，可以在**构造器或构造代码块**里面初始化，不能在普通方法里
  - 修饰方法，该方法不可以被重写（不然就是改变了这个方法的逻辑）
  - 修饰类，这个类不可以被继承（不然就影响了稳定性）
    - 虽然被final修饰了，不能更改指向，但是依然可以修改对象里面的成员（没有违背final）
  - 搭配static定义常量：public static final String baidu="www.baidu.com"
- static方法与重写产生的冲突



- 注解：标注解释
- 按照运行时期可分为：
  - 源码时，注解只会保留在源码阶段，编译后被丢弃（@Override就是在源码阶段为了使得编译器检查重写是否正确）
  - 编译时，编译之后也存在，但是加载class文件执行程序的时候就会保留（spring下的@NotNul）
  - 运行时，影响整个程序的周期（spring下的@Autowired）
- 元注解，标注注解的注解



- 设计模式是软件开发人员在开发过程中用经验总结的一套解决方法

- 单例模式，让类的一个对象成为该系统的唯一实例。一个类只有一个实例

- | 要点             | 实现                         |
  | ---------------- | ---------------------------- |
  | 1.只能有一个实例 | 1.提供私有构造方法           |
  | 2.自行创建系统   | 2.持有一个该类的静态私有对象 |
  | 3.提供实例       | 3.提供创建，获取的方法       |

- 饿汉式，对象创建过程中实例化

  - 创建对象实例的时候直接初始化
  - 空间换时间

- 懒汉式，静态公有方法中实例化

  - 类内实例对象创建时并不直接初始化，直到第一次调用get方法时，才完成初始化操作

  - 时间换空间

- 任务管理器就是一个单例